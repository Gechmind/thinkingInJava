#对象导论

* 抽象过程  
  * 机器模型->实际待解问题
  * 待解问题建模
  * 对象特征行为抽象 对象具有状态 *内部数据*、行为 *方法*和标识 *内存地址*
* 每个对象都有一个接口  
  * 创建抽象数据类型。新创建的类型与内置类型的运行方式一致
  * 方法调用 *消息接口*
* 每个对象都提供服务
  * 自己所能提供服务的聚合

* 隐藏一部分实现 边界控制
  * private 
  * public
  * protected
  * 包访问权限
  
* 代码复用
  * has-a  组合
* 继承
  * 对象：使用概念把数据和功能封装
  * __构建类型层次结构__
  * 导出类差异化 ——> 添加新方法  覆盖
    * __纯粹替代__ is-a
    * 添加新方法  __is-like-a__
  
  
* 多态
  * 后期绑定 __通过虚拟机方法表实现动态分派-从符号引用到直接引用__ <深入理解java虚拟机 Page-257 >
  * 强类型语言-> 编译器确保被调用方法的存在，并对调用参数和返回值执行类型检查  
  
***

#一切都是对象

* 用引用操作对象
* 对象创建——对象存储位置
  * 寄存器
  * 堆栈 RAM **通过堆栈的指针来创建和销毁对象**
  * 堆  RAM 
  * 常量存储 常量值放到代码内部存储 -->JVM 方法区(非堆 hotspot通过永久代实现)
  * 直接内存
* 基本类型 
  * 存储到堆栈中... __此处的基本类型应该值得是局部变量*（JVM局部变量表）*，实例的变量都是在常量池中__
  * 变量直接存储值而非引用
  * java的数组，jvm直接创建(其他对象通过类加载器创建）
* 永远不需要销毁对象
  * 作用域
* static关键字
  * 类数据和类方法  类方法——>虚拟机的静态解析，从符号应用到直接引用
  * 类数据的加载机制  JVM虚拟机类加载进入__准备__阶段,随对象实例化时分配到Java堆中
  * 类数据如果直接通过类引用来使用？ 此时的加载机制是怎样的
  * 通过类名引用static变量是首选方式  

***

# 操作符

* equals()方法和==
  * equals用于比较两个变量的引用是否相同，不适用于基本类型，如Integer包装类
  * == 对于基本类型比较两个变量的值是否相同，而在比较引用时，如果引用指向内存中的同一对象
  
* 按位操作符
  * 布尔类型可以作为单比特对待，可以进行按位“或”“异或”“与”操作
  
* 移位操作
  * << 左移位操作
  * \>> 有符号右移位操作
  * \>>> 无符号右移位操作
  * char,byte,short类型数据移位处理，转型成int
  
  
